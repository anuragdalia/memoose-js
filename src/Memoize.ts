import {CacheKey} from "./CacheKey";
import {CacheProvider, Pipeline} from "./adapters/base";
import {MemoryCacheProvider} from "./adapters";
import {RedisCacheProvider} from "./adapters";

export const stats: any = {redis: {}, memory: {}};

export class Memoize<T> {
    private readonly ttl: number;
    private readonly function_name: string;
    private readonly argsOrderVain: boolean;
    private readonly inMemory: boolean;
    private readonly storeAsObj: boolean;
    private func: Function;
    private cache_key: CacheKey;
    private readonly name: string;

    private cache: CacheProvider;

    static config: {
        MemoryCacheProvider: MemoryCacheProvider | null;
        RedisCacheProvider: RedisCacheProvider | null;
        local: boolean
    } = {
        local: true,
        RedisCacheProvider: null,
        MemoryCacheProvider: null
    }

    /**
     @param func the function who result is to be cached
     @param ttl the time in seconds for which the result is to be cached
     @param options When options.multi is true, the first parameter 'func' in memoize function would refer to the function which will be used to calculate result of a
      key, of which the value does not exists in the cache. options.funcName is to generate the same cache_key that would would generated by cached version of func.
      options.argsOrderVain for when parameters order doesn't matter
     @returns {Function}
     */
    constructor(func: Function, ttl: number = -1, options: {
        function_name?: string;
        argsOrderVain?: boolean;
        inMemory?: boolean
    } = {
        function_name: func.name,
        argsOrderVain: false,
        inMemory: false
    }) {
        this.func = func;
        this.ttl = ttl;
        this.function_name = options.function_name || func.name || "";
        this.argsOrderVain = !!options.argsOrderVain;
        this.inMemory = !!options.inMemory;
        this.storeAsObj = this.inMemory;
        this.name = this.inMemory ? "memory" : "redis";

        if (this.function_name === "")
            throw new Error("Anonymous functions can not be memoized. Either pass function_name in options");

        this.cache_key = new CacheKey(this.function_name, this.argsOrderVain);

        if (!Memoize.config.MemoryCacheProvider || !Memoize.config.RedisCacheProvider)
            throw new Error("Memory cache provider requires MemoryCacheProvider and RedisCacheProvider");

        this.cache = this.inMemory ? Memoize.config.MemoryCacheProvider : Memoize.config.RedisCacheProvider;

        stats[this.inMemory ? "memory" : "redis"][this.function_name] = stats[this.inMemory ? "memory" : "redis"][this.function_name] || {
            hit: 0,
            miss: 0,
            total: 0,
            adv_stats: {}
        };
    }

    public call(this: Memoize<T>, ...args: any[]): Promise<T> {
        const cache_key = this.cache_key.for(args);
        const start = Date.now();
        let isHit = true;
        return this.cache.get(cache_key)
            .then(obj => {
                if (obj === null || obj === undefined) {
                    isHit = false;
                    return this.executeAndCache(cache_key, ...args);
                }

                if (this.storeAsObj)
                    return obj.reject ? Promise.reject(obj.data) : Promise.resolve(obj.data);

                if (obj.indexOf('-reject-') === 0) {
                    obj = obj.substr('-reject-'.length);
                    return obj.indexOf('-undefined-') === 0 ? Promise.reject(undefined) : obj.indexOf('-null-') === 0 ? Promise.reject(null) : Promise.reject(JSON.parse(obj));
                } else {
                    return obj.indexOf('-undefined-') === 0 ? Promise.resolve(undefined) : obj.indexOf('-null-') === 0 ? Promise.resolve(null) : Promise.resolve(JSON.parse(obj));
                }
            })
            .then(resp => {
                if (!Memoize.config.local) return resp;
                const time_now = Date.now();
                const time_taken = time_now - start;
                if (isHit) stats[this.name][this.function_name].hit = stats[this.name][this.function_name].hit + 1;
                else stats[this.name][this.function_name].miss = stats[this.name][this.function_name].miss + 1;
                stats[this.name][this.function_name].total = stats[this.name][this.function_name].total + 1;
                stats[this.name][this.function_name]["adv_stats"][cache_key] = stats[this.name][this.function_name]["adv_stats"][cache_key] || {
                    hit: 0,
                    miss: 0,
                    total: 0,
                    history: []
                };

                if (isHit) stats[this.name][this.function_name]["adv_stats"][cache_key].hit = stats[this.name][this.function_name]["adv_stats"][cache_key].hit + 1;
                else stats[this.name][this.function_name]["adv_stats"][cache_key].miss = stats[this.name][this.function_name]["adv_stats"][cache_key].miss + 1;
                stats[this.name][this.function_name]["adv_stats"][cache_key].total = stats[this.name][this.function_name]["adv_stats"][cache_key].total + 1;
                const last = stats[this.name][this.function_name]["adv_stats"][cache_key].history.pop();
                if (last) {
                    stats[this.name][this.function_name]["adv_stats"][cache_key].history.push(last, {
                        time: Date.now(),
                        after: time_now - last.time,
                        type: isHit ? "hit" : "miss",
                        time_taken: time_taken
                    });
                } else {
                    stats[this.name][this.function_name]["adv_stats"][cache_key].history.push({
                        time: Date.now(),
                        after: time_now,
                        type: isHit ? "hit" : "miss",
                        time_taken: time_taken
                    });
                }
                return resp
            });
    };

    public update(...args: any[]): Promise<T> {

        let newValue = args.pop();
        if (!!newValue && !!newValue.updatedAt) newValue.updatedAt = Date.now();
        const cache_key = this.cache_key.for(args);
        return this.cache.set(cache_key, JSON.stringify(newValue), this.ttl).then(_value_as_string => newValue);
    };

    public demoize(...args: any[]): Promise<number> {
        const cache_key = this.cache_key.for(args);
        return this.cache.del(cache_key);
    };

    public cacheKey(...args: any[]): string {
        return this.cache_key.for(args);
    };

    public pipeline(): Pipeline {
        return this.cache.pipeline();
    };

    public refresh(...args: any[]): Promise<T> {

        let argsToGenerateKey = args.slice();
        if (this.argsOrderVain) argsToGenerateKey = argsToGenerateKey.sort();
        const cache_key = this.cache_key.for(argsToGenerateKey);
        return this.cache.del(cache_key)
            .then(obj => obj ? this.executeAndCache(cache_key, ...args) : Promise.resolve("didnt exists so not executing"));
    };

    public setExp(...args: any[]) {

        let newValue = args.pop();
        if (this.argsOrderVain) args = args.sort();
        const cache_key = this.cache_key.for(args);
        return this.cache.expire(cache_key, newValue);
    };

    public exec(...args: any[]) {
        const resp = this.func.apply(null, args);
        return (resp instanceof Promise) ? resp : Promise.resolve(resp);
    };

    private executeAndCache(cache_key: string, ...args: any[]) {
        return this.exec(...args)
            .then(resp => {
                this.saveToCache(resp, cache_key, this.ttl)
                return resp;
            })
            .catch(eResp => {
                this.saveToCache(eResp, cache_key, this.ttl, true)
                return Promise.reject(eResp);
            })
    }

    private saveToCache(resp_val_original: any, cache_key: string, ttl: number, rejection: boolean = false) {

        if (this.storeAsObj)
            return this.cache.set(cache_key, {data: resp_val_original, reject: rejection}, ttl);

        if (ttl <= 0) ttl = -1;
        let resp_val = JSON.stringify(resp_val_original);
        if (resp_val === undefined) resp_val = '-undefined-';
        if (resp_val === null) resp_val = '-null-';
        if (rejection) resp_val = `-reject-${resp_val}`;
        return this.cache.set(cache_key, resp_val, ttl)
            .catch(console.error.bind(null, cache_key, resp_val));
    };

    public multiCall(this: Memoize<T>, ...args: any[]): Promise<T[]> {
        if (args.length === 0) return Promise.resolve([])
        const cache_keys = args.map(arg => this.cache_key.for([].concat(arg)));
        const start = Date.now();
        const statsMarker = (cache_key: string, isHit: boolean) => {
            if (!Memoize.config.local) return;
            const time_now = Date.now();
            const time_taken = time_now - start;
            if (isHit) stats[this.name][this.function_name].hit = stats[this.name][this.function_name].hit + 1;
            else stats[this.name][this.function_name].miss = stats[this.name][this.function_name].miss + 1;
            stats[this.name][this.function_name].total = stats[this.name][this.function_name].total + 1;
            stats[this.name][this.function_name]["adv_stats"][cache_key] = stats[this.name][this.function_name]["adv_stats"][cache_key] || {
                hit: 0,
                miss: 0,
                total: 0,
                history: []
            };

            if (isHit) stats[this.name][this.function_name]["adv_stats"][cache_key].hit = stats[this.name][this.function_name]["adv_stats"][cache_key].hit + 1;
            else stats[this.name][this.function_name]["adv_stats"][cache_key].miss = stats[this.name][this.function_name]["adv_stats"][cache_key].miss + 1;
            stats[this.name][this.function_name]["adv_stats"][cache_key].total = stats[this.name][this.function_name]["adv_stats"][cache_key].total + 1;
            const last = stats[this.name][this.function_name]["adv_stats"][cache_key].history.pop();
            if (last) {
                stats[this.name][this.function_name]["adv_stats"][cache_key].history.push(last, {
                    time: Date.now(),
                    after: time_now - last.time,
                    type: isHit ? "hit" : "miss",
                    time_taken: time_taken
                });
            } else {
                stats[this.name][this.function_name]["adv_stats"][cache_key].history.push({
                    time: Date.now(),
                    after: time_now,
                    type: isHit ? "hit" : "miss",
                    time_taken: time_taken
                });
            }
        };

        return this.cache.mget(...cache_keys)
            .then((objs: (T | any)[]) => Promise.all(objs.map((obj, index) => {
                let isHit = true;
                if (obj === null || obj === undefined) {
                    isHit = false;
                    return this.executeAndCache(cache_keys[index], ...[].concat(args[index]));
                }
                statsMarker(cache_keys[index], isHit);

                if (this.storeAsObj)
                    return obj.reject ? Promise.reject(obj.data) : Promise.resolve(obj.data);

                if (obj.indexOf('-reject-') === 0) {
                    obj = obj.substr('-reject-'.length);
                    return obj.indexOf('-undefined-') === 0 ? Promise.reject(undefined) : obj.indexOf('-null-') === 0 ? Promise.reject(null) : Promise.reject(JSON.parse(obj));
                } else {
                    return obj.indexOf('-undefined-') === 0 ? Promise.resolve(undefined) : obj.indexOf('-null-') === 0 ? Promise.resolve(null) : Promise.resolve(JSON.parse(obj));
                }
            })));
    }
}
