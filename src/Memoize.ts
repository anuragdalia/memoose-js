import {CacheKeyGenerator as CacheKeyGenerator} from "./CacheKeyGenerator";
import {CacheKey, CacheProvider, Pipeline, TDeserializer, TSerializer, TTL} from "./adapters/base";
import {MemoryCacheProvider} from "./adapters";

export const stats: any = {redis: {}, memory: {}};

export type CachedItem = string | { data: any, reject: boolean }
export type MemoizeConfig<Args extends Array<any> = any[], T = any> = {
    functionName?: string;
    argsOrderVain?: boolean;
    cacheProvider?: CacheProvider<CachedItem>,
    cacheKeyGenerator?: CacheKeyGenerator,
    multiExecOverride?: (...argss: Args[]) => Promise<T[]>
}

export class Memoize<Args extends Array<any> = any[], ReturnType = any> {
    private readonly ttl: number;
    private readonly functionName: string;
    private readonly argsOrderVain: boolean;
    private readonly storeAsObj: boolean;
    private readonly serializer: TSerializer | undefined;
    private readonly deserializer: TDeserializer | undefined;
    private func: Function;
    private cacheKeyGenerator: CacheKeyGenerator;
    private readonly name: string;

    //expectation is all these resolve and none reject
    private readonly multiExecOverride: (...argss: Args[]) => Promise<ReturnType[]>;

    private cache: CacheProvider<CachedItem>;

    static config: {
        local: boolean
    } = {
        local: true,
    }

    /**
     @param func the function who result is to be cached
     @param ttl the time in seconds for which the result is to be cached
     @param options When options.multi is true, the first parameter 'func' in memoize function would refer to the function which will be used to calculate result of a
      key, of which the value does not exists in the cache. options.funcName is to generate the same cacheKeyGenerator that would would generated by cached version of func.
      options.argsOrderVain for when parameters order doesn't matter
     */
    constructor(func: Function, ttl: number = -1, options: MemoizeConfig<Args, ReturnType> = {}) {
        this.func = func;
        this.ttl = ttl;
        this.functionName = options.functionName || func.name || "";
        this.argsOrderVain = !!options.argsOrderVain;
        this.multiExecOverride = options.multiExecOverride || (function (...argss: Args[]) {
            return Promise.all(argss.map(args => func.apply(null, args)))
        })
        this.cacheKeyGenerator = options.cacheKeyGenerator || new CacheKeyGenerator(this.functionName, this.argsOrderVain);
        this.cache = options.cacheProvider || new MemoryCacheProvider();
        this.storeAsObj = this.cache.storesAsObj;
        this.serializer = this.cache.serializationOptions.serializer;
        this.deserializer = this.cache.serializationOptions.deserializer;
        this.name = this.cache.name();

        //add chunking for default function if needed
        if (this.functionName === "")
            throw new Error("Anonymous functions can not be memoized. You can pass functionName in options");

        stats[this.name][this.functionName] = stats[this.name][this.functionName] || {
            hit: 0,
            miss: 0,
            total: 0,
            adv_stats: {}
        };
    }

    private isCacheMiss(this: Memoize<Args, ReturnType>, obj?: CachedItem | null): obj is null {
        return obj === null || obj === undefined
    }

    private processedObjFromCache(this: Memoize<Args, ReturnType>, obj: CachedItem): Promise<ReturnType> {
        function processStr(obj: string, deserializer?: TDeserializer) {
            if (obj.indexOf('-undefined-') === 0)
                return undefined

            if (obj.indexOf('-null-') === 0)
                return null

            return JSON.parse(obj, deserializer)
        }

        if (this.storeAsObj && !isString(obj))
            return obj.reject ? Promise.reject(obj.data) : Promise.resolve(obj.data);

        if (!isString(obj))
            throw new Error("stored as string but got obj from cache?")

        if (obj.indexOf('-reject-') === 0)
            return Promise.reject(processStr(obj.substr('-reject-'.length), this.deserializer))
        else
            return Promise.resolve(processStr(obj, this.deserializer))
    }

    private processObjForCache(this: Memoize<Args, ReturnType>, obj: any, rejection: boolean = false) {
        if (this.storeAsObj) {
            return {data: obj, reject: rejection}
        } else {
            let resp_val = JSON.stringify(obj, this.serializer);
            if (resp_val === undefined) resp_val = '-undefined-';
            if (resp_val === null) resp_val = '-null-';
            if (rejection) resp_val = `-reject-${resp_val}`;
            return resp_val
        }
    }

    private pipeline(this: Memoize<Args, ReturnType>): Pipeline<CachedItem> {
        return this.cache.pipeline();
    };

    private statsMarkerGenerator = (start: number) => (cache_key: string, isHit: boolean) => {
        if (!Memoize.config.local) return;
        const time_now = Date.now();
        const time_taken = time_now - start;
        if (isHit) stats[this.name][this.functionName].hit = stats[this.name][this.functionName].hit + 1;
        else stats[this.name][this.functionName].miss = stats[this.name][this.functionName].miss + 1;
        stats[this.name][this.functionName].total = stats[this.name][this.functionName].total + 1;
        stats[this.name][this.functionName]["adv_stats"][cache_key] = stats[this.name][this.functionName]["adv_stats"][cache_key] || {
            hit: 0,
            miss: 0,
            total: 0,
            history: []
        };

        if (isHit) stats[this.name][this.functionName]["adv_stats"][cache_key].hit = stats[this.name][this.functionName]["adv_stats"][cache_key].hit + 1;
        else stats[this.name][this.functionName]["adv_stats"][cache_key].miss = stats[this.name][this.functionName]["adv_stats"][cache_key].miss + 1;
        stats[this.name][this.functionName]["adv_stats"][cache_key].total = stats[this.name][this.functionName]["adv_stats"][cache_key].total + 1;
        const last = stats[this.name][this.functionName]["adv_stats"][cache_key].history.pop();
        if (last) {
            stats[this.name][this.functionName]["adv_stats"][cache_key].history.push(last, {
                time: Date.now(),
                after: time_now - last.time,
                type: isHit ? "hit" : "miss",
                time_taken: time_taken
            });
        } else {
            stats[this.name][this.functionName]["adv_stats"][cache_key].history.push({
                time: Date.now(),
                after: time_now,
                type: isHit ? "hit" : "miss",
                time_taken: time_taken
            });
        }
    };

    //public

    public cacheKey(this: Memoize<Args, ReturnType>, ...args: Args): string {
        return this.cacheKeyGenerator.for(...args);
    };

    //function single call

    private async executeAndCache(this: Memoize<Args, ReturnType>, cache_key: CacheKey, ...args: Args) {
        try {
            let resp = await this.exec(...args);
            this.saveToCache(resp, cache_key, this.ttl)
            return resp;
        } catch (eResp: any) {
            this.saveToCache(eResp, cache_key, this.ttl, true)
            return Promise.reject(eResp);
        }
    }

    private async saveToCache(this: Memoize<Args, ReturnType>, resp_val_original: ReturnType | any, cache_key: CacheKey, ttl: TTL, rejection: boolean = false) {
        if (ttl <= 0) ttl = -1;
        const resp_val = this.processObjForCache(resp_val_original, rejection)
        await this.cache.set(cache_key, resp_val, ttl)
            .catch(console.error.bind(null, cache_key, resp_val));
    };

    public async exec(this: Memoize<Args, ReturnType>, ...args: Args): Promise<ReturnType> {
        return this.func.apply(null, args)
    };

    public async call(this: Memoize<Args, ReturnType>, ...args: Args): Promise<ReturnType> {
        const cache_key = this.cacheKeyGenerator.for(...args);
        const statsMarker = this.statsMarkerGenerator(Date.now())
        let isHit = true;
        const obj = await this.cache.get(cache_key)
        if (this.isCacheMiss(obj)) {
            isHit = false;
            return this.executeAndCache(cache_key, ...args);
        }
        statsMarker(cache_key, isHit)
        return this.processedObjFromCache(obj)
    };

    public async update(this: Memoize<Args, ReturnType>, ...argsAndValue: [...Args, ReturnType]): Promise<ReturnType> {
        let newValue = argsAndValue.pop() as ReturnType;
        let args = argsAndValue as any as Args

        const cache_key = this.cacheKeyGenerator.for(...args);
        let item = this.processObjForCache(newValue)
        await this.cache.set(cache_key, item, this.ttl)
        return newValue
    };

    public async demoize(this: Memoize<Args, ReturnType>, ...args: Args): Promise<number> {
        const cache_key = this.cacheKeyGenerator.for(...args);
        return this.cache.del(cache_key);
    };

    public async refresh(this: Memoize<Args, ReturnType>, ...args: Args): Promise<any> {
        //doesnt refresh if it doesnt exist in cache
        const cache_key = this.cacheKey(...args);
        const didDelete = await this.cache.del(cache_key)
        if (didDelete)
            await this.executeAndCache(cache_key, ...args)

        return Promise.resolve()
    };

    public async setExp(this: Memoize<Args, ReturnType>, ...argsAndTTL: [...Args, TTL]) {
        let newTTL = argsAndTTL.pop() as TTL;
        let args = argsAndTTL as any as Args
        const cache_key = this.cacheKey(...args);
        return this.cache.expire(cache_key, newTTL);
    };

    //function multi call

    private async multiExecuteAndCache(this: Memoize<Args, ReturnType>, ...cache_key_and_args_s: [CacheKey, Args][]): Promise<ReturnType[]> {
        const argssToExec = cache_key_and_args_s.map(([cacheKey, args]) => args)
        const newRespGen = await this.multiExec(...argssToExec)

        const argsToSaveToCache: [ReturnType, CacheKey, TTL, boolean][] = []
        for (let i = 0; i < cache_key_and_args_s.length; i++) {
            const [cacheKey, args] = cache_key_and_args_s[i];
            const resp = await newRespGen[i];
            argsToSaveToCache.push([resp, cacheKey, this.ttl, false])
        }

        this.multiSaveToCache(...argsToSaveToCache)

        return newRespGen;
    }

    private async multiSaveToCache(this: Memoize<Args, ReturnType>, ...argss: [ReturnType, CacheKey, TTL, boolean][]) {
        if (!argss.length) return
        const toCache: [CacheKey, string | { data: any, reject: boolean }][] = []
        for (let i = 0; i < argss.length; i++) {
            let [resp_val_original, cache_key, ttl, rejection] = argss[i]
            if (ttl <= 0) ttl = -1;
            toCache.push([cache_key, this.processObjForCache(resp_val_original, rejection)])
        }

        await this.cache.mset(...toCache)
    }

    public async multiExec(this: Memoize<Args, ReturnType>, ...argss: Args[]) {
        return this.multiExecOverride.apply(null, argss);
    };

    public async multiCall(this: Memoize<Args, ReturnType>, ...argss: Args[]): Promise<ReturnType[]> {
        if (argss.length === 0)
            return Promise.resolve([])
        const cacheKeys = argss.map((args) => this.cacheKeyGenerator.for(...args));
        const statsMarker = this.statsMarkerGenerator(Date.now())

        const redisHits: any[] = await this.cache.mget(...cacheKeys)

        const misses: [number, [CacheKey, Args]][] = []
        const hits: [number, [CacheKey, Args], ReturnType][] = []

        for (let i = 0; i < redisHits.length; i++) {
            const obj = redisHits[i];
            let isHit = true
            if (obj === null || obj === undefined) {
                isHit = false
                misses.push([i, [cacheKeys[i], argss[i]]])
            } else {
                hits.push([i, [cacheKeys[i], argss[i]], await this.processedObjFromCache(obj)])
            }
            statsMarker(cacheKeys[i], isHit)
        }

        const arggsToExecAndCache: [CacheKey, Args][] = misses.map(([idx, [cache_key, args]]) => [cache_key, args])

        const newResps: ReturnType[] = await this.multiExecuteAndCache(...arggsToExecAndCache)

        if (misses.length !== newResps.length)
            throw new Error(`misses:${misses.length} !== newResps:${newResps.length}`)

        for (let i = 0; i < misses.length; i++) {
            const resp = newResps[i]
            const [idx, [cache_key, args]] = misses[i]
            hits.push([idx, [cache_key, args], resp])
        }

        hits.sort((hit1, hit2) => hit1[0] > hit2[0] ? 1 : -1);

        return hits.map(hit => hit[2])
    }
}

function isString(input: any): input is string {
    return typeof input === "string"
}
